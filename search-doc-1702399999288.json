[{"title":"Installation","type":0,"sectionRef":"#","url":"/TableValue/docs/intro","content":"","keywords":""},{"title":"Manually​","type":1,"pageTitle":"Installation","url":"/TableValue/docs/intro#manually","content":"Copy the source code from src/init.luaPaste it into a ModuleScript or file "},{"title":"Wally Package Manager​","type":1,"pageTitle":"Installation","url":"/TableValue/docs/intro#wally-package-manager","content":"Go to wally.run and click the text under Install on the rightPaste it under Dependencies in your wally.toml file "},{"title":"TableValue","type":0,"sectionRef":"#","url":"/TableValue/api/TableValue","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableValue","url":"/TableValue/api/TableValue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TableValue","url":"/TableValue/api/TableValue#new","content":"&lt;/&gt; TableValue.new( tab: T, changed: ( key: any, new: any, old: any ) → ()? ) → T&amp;{ Value: T, Changed: ( key: any, new: any, old: any ) → () } Returns a new proxy table to interface with the .Value table. Does not modify the .Value table or its metatable. The callback is optional, if it is defined it will automatically update the fields in the table at initialization. local person = TableValue.new { name = 'Jim', age = 9, } function person.Changed(key: string, new, old) print(key, new, old) end person.age += 1 -- print('age', 10, 9) person.Value.age += 1 -- No callback fires, this is how you can perform silent changes! local monster = TableValue.new({ type = 'large', health = 100, secret = 'Loves chocolate' }, function(key: string, new, old) print(key, new, old) end) -- print('health', 100, nil) -- print('type', &quot;large&quot;, nil) -- print('secret', 'Loves chocolate', nil) monster.health -= 10 -- print('health', 90, 100) monster.Value.secret ..= ' but is lactose intolerant' -- No callback fires, this is how you can perform silent changes! If the callback doesn't suit your fancy, you can make a small wrapper for it to use a signal instead! function MyValue.signal(tab: { [any]: any }) local self = TableValue.new(tab) self.Signal = Signal.new() function self.Changed(key, new, old) self.Signal:Fire(key, new, old) end return self end local person = MyValue.new { name = 'Jim', age = 9, } person.Signal:Connect(function(key: string, new, old) print(key, new, old) end) person.age += 1 -- print('age', 10, 9) person.Value.age += 1 -- No event fires, this is how you can perform silent changes!   "},{"title":"insert​","type":1,"pageTitle":"TableValue","url":"/TableValue/api/TableValue#insert","content":"&lt;/&gt; TableValue.insert( tab: {Value: {T}}, value: T, index: number? ) → () Mimics table.insert, except the index always comes last. By nature not as optimal as table.insert on a regular table. local myArray = TableValue.new {} function myArray.Changed(index, value) print(index, value) end TableValue.insert(myArray, 'World') -- print(1, 'World') TableValue.insert(myArray, 'Hello', 1) -- print(2, 'World') -- print(1, 'Hello') print(myArray.Value) -- { 'Hello', 'World' }   "},{"title":"remove​","type":1,"pageTitle":"TableValue","url":"/TableValue/api/TableValue#remove","content":"&lt;/&gt; TableValue.remove( tab: {Value: {T}}, index: number? ) → T Mimics table.remove. By nature not as optimal as table.remove on a regular table. local myArray = TableValue.new { 3, 'hi', Vector3.zero } function myArray.Changed(index, value) print(index, value) end TableValue.remove(myArray, 2) -- print(2, Vector3.zero) -- print(3, nil) TableValue.remove(myArray, 1) -- print(1, Vector3.zero) -- print(2, nil) print(myArray.Value) -- { Vector3.zero }  "}]